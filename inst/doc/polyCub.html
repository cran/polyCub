<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">
<title>Getting started with polyCub</title>
<style type="text/css">
/**
 * Prism.s theme ported from highlight.js's xcode style
 */
pre code {
  padding: 1em;
}
.token.comment {
  color: #007400;
}
.token.punctuation {
  color: #999;
}
.token.tag,
.token.selector {
  color: #aa0d91;
}
.token.boolean,
.token.number,
.token.constant,
.token.symbol {
  color: #1c00cf;
}
.token.property,
.token.attr-name,
.token.string,
.token.char,
.token.builtin {
  color: #c41a16;
}
.token.inserted {
  background-color: #ccffd8;
}
.token.deleted {
  background-color: #ffebe9;
}
.token.operator,
.token.entity,
.token.url,
.language-css .token.string,
.style .token.string {
  color: #9a6e3a;
}
.token.atrule,
.token.attr-value,
.token.keyword {
  color: #836c28;
}
.token.function,
.token.class-name {
  color: #DD4A68;
}
.token.regex,
.token.important,
.token.variable {
  color: #5c2699;
}
.token.important,
.token.bold {
  font-weight: bold;
}
.token.italic {
  font-style: italic;
}
</style>
<style type="text/css">
body {
  font-family: sans-serif;
  max-width: 800px;
  margin: auto;
  padding: 1em;
  line-height: 1.5;
  box-sizing: border-box;
}
body, .footnotes, code { font-size: .9em; }
li li { font-size: .95em; }
*, *:before, *:after {
  box-sizing: inherit;
}
pre, img { max-width: 100%; }
pre, pre:hover {
  white-space: pre-wrap;
  word-break: break-all;
}
pre code {
  display: block;
  overflow-x: auto;
}
code { font-family: 'DejaVu Sans Mono', 'Droid Sans Mono', 'Lucida Console', Consolas, Monaco, monospace; }
:not(pre) > code, code[class] { background-color: #F8F8F8; }
code.language-undefined, pre > code:not([class]) {
  background-color: inherit;
  border: 1px solid #eee;
}
table {
  margin: auto;
  border-top: 1px solid #666;
}
table thead th { border-bottom: 1px solid #ddd; }
th, td { padding: 5px; }
thead, tfoot, tr:nth-child(even) { background: #eee; }
blockquote {
  color: #666;
  margin: 0;
  padding-left: 1em;
  border-left: 0.5em solid #eee;
}
hr, .footnotes::before { border: 1px dashed #ddd; }
.frontmatter { text-align: center; }
#TOC .numbered li { list-style: none; }
#TOC .numbered { padding-left: 0; }
#TOC .numbered ul { padding-left: 1em; }
table, .body h2 { border-bottom: 1px solid #666; }
.body .appendix, .appendix ~ h2 { border-bottom-style: dashed; }
.footnote-ref a::before { content: "["; }
.footnote-ref a::after { content: "]"; }
section.footnotes::before {
  content: "";
  display: block;
  max-width: 20em;
}

@media print {
  body {
    font-size: 12pt;
    max-width: 100%;
  }
  tr, img { page-break-inside: avoid; }
}
@media only screen and (min-width: 992px) {
  pre { white-space: pre; }
}
</style>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex/dist/katex.min.css">
</head>
<body>
<div class="frontmatter">
<div class="title"><h1>Getting started with polyCub</h1></div>
<div class="author"><h2>Sebastian Meyer</h2></div>
<div class="date"><h3>2024-05-21</h3></div>
</div>
<div class="body">
<!--
%\VignetteIndexEntry{Getting started with polyCub}
%\VignetteEngine{knitr::knitr}
%\VignetteDepends{polyCub, spatstat.geom, markdown}
%%                                        ^ implied by the engine
-->
<img src="data:image/png;base64,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" align="right" alt="" width="120" />
<p>The R package <strong>polyCub</strong> implements <em>cubature</em> (numerical integration)
over <em>polygonal</em> domains.
It solves the problem of integrating a continuously differentiable
function f(x,y) over simple closed polygons.</p>
<p>For the special case of a rectangular domain along the axes, the package
<a href="https://CRAN.R-project.org/package=cubature"><strong>cubature</strong></a>
is more appropriate (cf.
<a href="https://CRAN.R-project.org/view=NumericalMathematics"><code>CRAN Task View: Numerical Mathematics</code></a>).</p>
<h2 id="polygon-representations">Polygon representations</h2>
<p>The integration domain is described by a polygonal boundary
(or multiple polygons, including holes).
Various R packages for spatial data analysis provide classes for polygons.
The implementations differ in vertex order (which direction represents a hole)
and if the first vertex is repeated.</p>
<p>All of <strong>polyCub</strong>’s cubature methods understand</p>
<ul>
<li>
<p><code>&quot;owin&quot;</code> from package <a href="https://CRAN.R-project.org/package=spatstat.geom"><strong>spatstat.geom</strong></a>,</p>
</li>
<li>
<p><code>&quot;gpc.poly&quot;</code> from <a href="https://github.com/rdpeng/gpclib/"><strong>gpclib</strong></a>,</p>
</li>
<li>
<p><code>&quot;SpatialPolygons&quot;</code> from package <a href="https://CRAN.R-project.org/package=sp"><strong>sp</strong></a>, and</p>
</li>
<li>
<p><code>&quot;(MULTI)POLYGON&quot;</code> from package <a href="https://CRAN.R-project.org/package=sf"><strong>sf</strong></a>.</p>
</li>
</ul>
<p>Internally, <strong>polyCub</strong> uses its auxiliary <code>xylist()</code> function to extract
a plain list of lists of vertex coordinates from these classes,
such that vertices are ordered anticlockwise (for exterior boundaries)
and the first vertex is not repeated (i.e., the <code>&quot;owin&quot;</code> convention).</p>
<h2 id="cubature-methods">Cubature methods</h2>
<p>The following cubature methods are implemented in <strong>polyCub</strong>:</p>
<ol>
<li>
<p><code>polyCub.SV()</code>: Product Gauss cubature</p>
</li>
<li>
<p><code>polyCub.midpoint()</code>: Two-dimensional midpoint rule</p>
</li>
<li>
<p><code>polyCub.iso()</code>: Adaptive cubature for radially symmetric functions
\(f(x,y) = f_r(\lVert(x-x_0,y-y_0)\rVert)\)</p>
</li>
<li>
<p><code>polyCub.exact.Gauss()</code> (<em>currently disabled</em>): Accurate integration of the
bivariate Gaussian density</p>
</li>
</ol>
<p>The following section details and illustrates the different cubature methods.</p>
<h2 id="illustrations">Illustrations</h2>
<pre><code class="language-r">library(&quot;polyCub&quot;)
</code></pre>
<p>We consider the integration of a function f(x,y) which all of the above
cubature methods can handle: an isotropic zero-mean Gaussian density.
<strong>polyCub</strong> expects the integrand f to take a two-column
coordinate matrix as its first argument (as opposed to separate arguments
for the x and y coordinates), so:</p>
<pre><code class="language-r">f &lt;- function (s, sigma = 5)
{
    exp(-rowSums(s^2)/2/sigma^2) / (2*pi*sigma^2)
}
</code></pre>
<p>We use a simple hexagon as polygonal integration domain,
here specified via an <code>&quot;xylist&quot;</code> of vertex coordinates:</p>
<pre><code class="language-r">hexagon &lt;- list(
    list(x = c(7.33, 7.33, 3, -1.33, -1.33, 3),
         y = c(-0.5, 4.5, 7, 4.5, -0.5, -3))
)
</code></pre>
<p>An image of the function and the integration domain can be produced using
<strong>polyCub</strong>’s rudimentary (but convenient) plotting utility:</p>
<pre><code class="language-r">plotpolyf(hexagon, f, xlim = c(-8,8), ylim = c(-8,8))
</code></pre>
<p><img src="data:image/png;base64,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" alt="plot of chunk example" /></p>
<h3 id="1-product-gauss-cubature-polycub-sv">1. Product Gauss cubature: <code>polyCub.SV()</code></h3>
<p>The <strong>polyCub</strong> package provides an R-interfaced C-translation of
“polygauss: Matlab code for Gauss-like cubature over polygons”
(Sommariva and Vianello, 2013, <a href="https://www.math.unipd.it/~alvise/software.html">https://www.math.unipd.it/~alvise/software.html</a>),
an algorithm described in Sommariva and Vianello (2007,
<em>BIT Numerical Mathematics</em>, <a href="https://doi.org/10.1007/s10543-007-0131-2">https://doi.org/10.1007/s10543-007-0131-2</a>).
The cubature rule is based on Green’s integration formula and incorporates
appropriately transformed weights and nodes of one-dimensional
Gauss-Legendre quadrature in both dimensions,
thus the name “product Gauss cubature”.
It is exact for all bivariate polynomials if the number of cubature nodes
is sufficiently large (depending on the degree of the polynomial).</p>
<p>For the above example, a reasonable approximation is already obtained
with degree <code>nGQ = 3</code> of the one-dimensional Gauss-Legendre quadrature:</p>
<pre><code class="language-r">polyCub.SV(hexagon, f, nGQ = 3, plot = TRUE)
#&gt; [1] 0.2741456
</code></pre>
<p><img src="data:image/png;base64,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" alt="plot of chunk product-Gauss" /></p>
<p>The involved nodes (displayed in the figure above) and weights can be
extracted by calling <code>polyCub.SV()</code> with <code>f = NULL</code>, e.g., to determine
the number of nodes:</p>
<pre><code class="language-r">nrow(polyCub.SV(hexagon, f = NULL, nGQ = 3)[[1]]$nodes)
#&gt; [1] 72
</code></pre>
<p>For illustration, we create a variant of <code>polyCub.SV()</code>,
which returns the number of function evaluations as an attribute:</p>
<pre><code class="language-r">polyCub.SVn &lt;- function (polyregion, f, ..., nGQ = 20) {
    nw &lt;- polyCub.SV(polyregion, f = NULL, ..., nGQ = nGQ)
    ## nw is a list with one element per polygon of 'polyregion'
    res &lt;- sapply(nw, function (x)
        c(result = sum(x$weights * f(x$nodes, ...)), nEval = nrow(x$nodes)))
    structure(sum(res[&quot;result&quot;,]), nEval = sum(res[&quot;nEval&quot;,]))
}
polyCub.SVn(hexagon, f, nGQ = 3)
#&gt; [1] 0.2741456
#&gt; attr(,&quot;nEval&quot;)
#&gt; [1] 72
</code></pre>
<p>We can use this function to investigate how the accuracy of the
approximation depends on the degree <code>nGQ</code> and the associated number of
cubature nodes:</p>
<pre><code class="language-r">for (nGQ in c(1:5, 10, 20)) {
    result &lt;- polyCub.SVn(hexagon, f, nGQ = nGQ)
    cat(sprintf(&quot;nGQ = %2i: %.12f (n=%i)\n&quot;, nGQ, result, attr(result, &quot;nEval&quot;)))
}
#&gt; nGQ =  1: 0.285265369245 (n=12)
#&gt; nGQ =  2: 0.274027610314 (n=36)
#&gt; nGQ =  3: 0.274145638288 (n=72)
#&gt; nGQ =  4: 0.274144768964 (n=120)
#&gt; nGQ =  5: 0.274144773834 (n=180)
#&gt; nGQ = 10: 0.274144773813 (n=660)
#&gt; nGQ = 20: 0.274144773813 (n=2520)
</code></pre>
<h3 id="2-two-dimensional-midpoint-rule-polycub-midpoint">2. Two-dimensional midpoint rule: <code>polyCub.midpoint()</code></h3>
<p>The two-dimensional midpoint rule in <strong>polyCub</strong> is a simple wrapper
around <code>as.im.function()</code> and <code>integral.im()</code> from package <strong>spatstat.geom</strong>.
In other words, the polygon is represented by a binary pixel image and
the integral is approximated as the sum of (pixel area * f(pixel midpoint))
over all pixels whose midpoint is part of the polygon.</p>
<p>To use <code>polyCub.midpoint()</code>, we need to convert our polygon to
<strong>spatstat.geom</strong>’s “owin” class:</p>
<pre><code class="language-r">library(&quot;spatstat.geom&quot;)
hexagon.owin &lt;- owin(poly = hexagon)
</code></pre>
<p>Using a pixel size of <code>eps = 0.5</code> (here yielding 270 pixels), we obtain:</p>
<pre><code class="language-r">polyCub.midpoint(hexagon.owin, f, eps = 0.5, plot = TRUE)
#&gt; [1] 0.2736067
</code></pre>
<p><img src="data:image/png;base64,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" alt="plot of chunk midpoint" /></p>
<h3 id="3-adaptive-cubature-for-isotropic-functions-polycub-iso">3. Adaptive cubature for <em>isotropic</em> functions: <code>polyCub.iso()</code></h3>
<p>A radially symmetric function can be expressed in terms of
the distance r from its point of symmetry: f(r).
If the antiderivative of r times f(r), called <code>intrfr()</code>, is
analytically available, Green’s theorem leads us to a cubature rule
which only needs <em>one-dimensional</em> numerical integration.
More specifically, <code>intrfr()</code> will be <code>integrate()</code>d along the edges of
the polygon. The mathematical details are given in
Meyer and Held (2014, <em>The Annals of Applied Statistics</em>,
<a href="https://doi.org/10.1214/14-AOAS743">https://doi.org/10.1214/14-AOAS743</a>, Supplement B, Section 2.4).</p>
<p>For the bivariate Gaussian density <code>f</code> defined above,
the integral from 0 to R of <code>r*f(r)</code> is analytically available as:</p>
<pre><code class="language-r">intrfr &lt;- function (R, sigma = 5)
{
    (1 - exp(-R^2/2/sigma^2))/2/pi
}
</code></pre>
<p>With this information, we can apply the cubature rule as follows:</p>
<pre><code class="language-r">polyCub.iso(hexagon, intrfr = intrfr, center = c(0,0))
#&gt; [1] 0.2741448
#&gt; attr(,&quot;abs.error&quot;)
#&gt; [1] 3.043618e-15
</code></pre>
<p>Note that we do not even need the original function <code>f</code>.</p>
<p>If <code>intrfr()</code> is missing, it can be approximated numerically using
<code>integrate()</code> for <code>r*f(r)</code> as well, but the overall integration will then
be much less efficient than product Gauss cubature.</p>
<p>Package <strong>polyCub</strong> exposes a C-version of <code>polyCub.iso()</code>
for use by other R packages (notably
<a href="https://CRAN.R-project.org/package=surveillance"><strong>surveillance</strong></a>) via
<code>LinkingTo: polyCub</code> and <code>#include &lt;polyCubAPI.h&gt;</code>.
This requires the <code>intrfr()</code> function to be implemented in C as well. See
<a href="https://github.com/bastistician/polyCub/blob/master/tests/polyiso_powerlaw.c">https://github.com/bastistician/polyCub/blob/master/tests/polyiso_powerlaw.c</a>
for an example.</p>
<h3 id="4-integration-of-the-bivariate-gaussian-density-polycub-exact-gauss">4. Integration of the <em>bivariate Gaussian density</em>: <code>polyCub.exact.Gauss()</code></h3>
<p><em>This cubature method is currently disabled</em>
(<a href="https://github.com/bastistician/polyCub/issues/2">#2</a>).
It requires polygon triangulation originally performed using <code>tristrip()</code>
from the <a href="https://github.com/rdpeng/gpclib/"><strong>gpclib</strong></a> package;
unfortunately, it has become unavailable from mainstream repositories.</p>
<p>Abramowitz and Stegun (1972, Section 26.9, Example 9) offer a formula for
the integral of the bivariate Gaussian density over a triangle with one
vertex at the origin. This formula can be used after triangulation of
the polygonal domain.
The core of the formula is an integral of the bivariate Gaussian density
with zero mean, unit variance and some correlation over an infinite rectangle
[h, Inf] x [0, Inf], which can be computed accurately using <code>pmvnorm()</code>
from the <a href="https://CRAN.R-project.org/package=mvtnorm"><strong>mvtnorm</strong></a> package.</p>
<p>For the above example, we obtained:</p>
<pre><code class="language-r">polyCub.exact.Gauss(hexagon.owin, mean = c(0,0), Sigma = 5^2*diag(2))
#&gt; [1] 0.2741448
#&gt; attr(,&quot;nEval&quot;)
#&gt; [1] 48
#&gt; attr(,&quot;error&quot;)
#&gt; [1] 4.6e-14
</code></pre>
<p>The required triangulation as well as the numerous calls of <code>pmvnorm()</code>
make this integration algorithm quite cumbersome. For large-scale
integration tasks, it is thus advisable to resort to the general-purpose
product Gauss cubature rule <code>polyCub.SV()</code>.</p>
<p>Note: <strong>polyCub</strong> provides an auxiliary function <code>circleCub.Gauss()</code> to
calculate the integral of an <em>isotropic</em> Gaussian density over a <em>circular</em>
domain (which requires nothing more than a single call of <code>pchisq()</code>).</p>
<h2 id="benchmark">Benchmark</h2>
<p>We use the last result from <code>polyCub.exact.Gauss()</code> as a reference value and
tune the number of cubature nodes in <code>polyCub.SV()</code> and <code>polyCub.midpoint()</code>
until the absolute error is below \(10^{-8}\).
This leads to <code>nGQ = 4</code> for product Gauss cubature
and a 1200 x 1200 pixel image for the midpoint rule.
For <code>polyCub.iso()</code>, we keep the default tolerance levels of <code>integrate()</code>.
For comparison, we also run <code>polyCub.iso()</code> without the analytically derived
<code>intrfr</code> function, which leads to a double-<code>integrate</code> approximation.</p>
<p>The median runtimes [ms] of the different cubature methods are given below.</p>
<pre><code class="language-r">benchmark &lt;- microbenchmark::microbenchmark(
  SV = polyCub.SV(hexagon.owin, f, nGQ = 4),
  midpoint = polyCub.midpoint(hexagon.owin, f, dimyx = 1200),
  iso = polyCub.iso(hexagon.owin, intrfr = intrfr, center = c(0,0)),
  iso_double_approx = polyCub.iso(hexagon.owin, f, center = c(0,0)),
  exact = polyCub.exact.Gauss(hexagon.owin, mean = c(0,0), Sigma = 5^2*diag(2)),
  times = 9,
  check = function (values) all(abs(unlist(values) - 0.274144773813434) &lt; 1e-8))
</code></pre>
<pre><code class="language-r">summary(benchmark, unit = &quot;ms&quot;)[c(&quot;expr&quot;, &quot;median&quot;)]
</code></pre>
<table>
<thead>
<tr>
<th align="left">expr</th>
<th align="right">median</th>
</tr>
</thead>
<tbody>
<tr>
<td align="left">SV</td>
<td align="right">0.08</td>
</tr>
<tr>
<td align="left">midpoint</td>
<td align="right">163.01</td>
</tr>
<tr>
<td align="left">iso</td>
<td align="right">0.27</td>
</tr>
<tr>
<td align="left">iso_double_approx</td>
<td align="right">3.91</td>
</tr>
<tr>
<td align="left">exact</td>
<td align="right">7.11</td>
</tr>
</tbody>
</table>
<p>The general-purpose SV-method is the clear winner of this small competition.
A disadvantage of that method is that the number of cubature nodes needs to be
tuned manually. This also holds for the midpoint rule, which is by far the
slowest option. In contrast, the “iso”-method for radially symmetric functions
is based on R’s <code>integrate()</code> function, which implements automatic tolerance
levels. Furthermore, the “iso”-method can also be used with “spiky” integrands,
such as a heavy-tailed power-law kernel \(f(r) = (r+1)^{-2}\).</p>
</div>
<script src="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/components/prism-core.min.js" defer></script>
<script src="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/plugins/autoloader/prism-autoloader.min.js" defer></script>
<script src="https://cdn.jsdelivr.net/combine/npm/katex/dist/katex.min.js,npm/katex/dist/contrib/auto-render.min.js,npm/@xiee/utils/js/render-katex.js" defer></script>
</body>
</html>
